---
layout: default
title: GType
nav_order: 5
description: 'Graph Type for PostGraph'
--- 

# Gtype

Gtype is the composite datatype for PostGraph. Based off of JsonB, it is capable of storing multiple other datatypes.

## Integer

The integer store whole numbers, that is, numbers without fractional components, of various ranges. Attempts to store values outside of the allowed range will result in an error.

## Float
A float in PostGraph is an 8-byte inexact variable-precise number. It offers 15 decimal digits of precision.

The data type double precision are inexact, variable-precision numeric types. On all currently supported platforms, these types are implementations of IEEE Standard 754 for Binary Floating-Point Arithmetic (single and double precision, respectively), to the extent that the underlying processor, operating system, and compiler support it.

Inexact means that some values cannot be converted exactly to the internal format and are stored as approximations, so that storing and retrieving a value might show slight discrepancies. Managing these errors and how they propagate through calculations is the subject of an entire branch of mathematics and computer science and will not be discussed here, except for the following points:

- If you require exact storage and calculations (such as for monetary amounts), use the numeric type instead.
- If you want to do complicated calculations with these types for anything important, especially if you rely on certain behavior in boundary cases (infinity, underflow), you should evaluate the implementation carefully.
- Comparing two floating-point values for equality might not always work as expected.

On all currently supported platforms, the double precision type has a range of around 1E-307 to 1E+308 with a precision of at least 15 digits. Values that are too large or too small will cause an error. Rounding might take place if the precision of an input number is too high. Numbers too close to zero that are not representable as distinct from zero will cause an underflow error.

By default, floating point values are output in text form in their shortest precise decimal representation; the decimal value produced is closer to the true stored binary value than to any other value representable in the same binary precision. (However, the output value is currently never exactly midway between two representable values, in order to avoid a widespread bug where input routines do not properly respect the round-to-nearest-even rule.) This value will use at most 17 significant decimal digits for float8 values, and at most 9 digits for float4 values.

**Note** This shortest-precise output format is much faster to generate than the historical rounded format.

For compatibility with output generated by older versions of PostgreSQL, and to allow the output precision to be reduced, the extra_float_digits parameter can be used to select rounded decimal output instead. Setting a value of 0 restores the previous default of rounding the value to 6 (for float4) or 15 (for float8) significant decimal digits. Setting a negative value reduces the number of digits further; for example -2 would round output to 4 or 13 digits respectively.

Any value of extra_float_digits greater than 0 selects the shortest-precise format.

**Note** Applications that wanted precise values have historically had to set extra_float_digits to 3 to obtain them. For maximum compatibility between versions, they should continue to do so.

In addition to ordinary numeric values, the floating-point types have several special values:
`Infinity`
`-Infinity`
`NaN`

These represent the IEEE 754 special values “infinity”, “negative infinity”, and “not-a-number”, respectively. When writing these values as constants in an Cypher command, you do not put quotes around them, for example MATCH (v) SET v.i = -Infinity. On input, these strings are recognized in a case-sensitive manner. The infinity values can alternatively be spelled inf and -inf.

**Note** IEEE 754 specifies that NaN should not compare equal to any other floating-point value (including NaN). In order to allow floating-point values to be sorted and used in tree-based indexes, PostgreSQL treats NaN values as equal, and greater than all non-NaN values.

PostgreSQL also supports the SQL-standard notations float and float(p) for specifying inexact numeric types. Here, p specifies the minimum acceptable precision in binary digits. PostgreSQL accepts float(1) to float(24) as selecting the real type, while float(25) to float(53) select double precision. Values of p outside the allowed range draw an error. float with no precision specified is taken to mean double precision.

## Numeric

The type numeric can store numbers with a very large number of digits. It is especially recommended for storing monetary amounts and other quantities where exactness is required. Calculations with numeric values yield exact results where possible, e.g., addition, subtraction, multiplication. However, calculations on numeric values are very slow compared to the integer types, or to the floating-point types described in the previous two sections.

We use the following terms below: The precision of a numeric is the total count of significant digits in the whole number, that is, the number of digits to both sides of the decimal point. The scale of a numeric is the count of decimal digits in the fractional part, to the right of the decimal point. So the number 23.5141 has a precision of 6 and a scale of 4. Integers can be considered to have a scale of zero.

PostGraph creates an “unconstrained numeric” column in which numeric values of any length can be stored, up to the implementation limits. A column of this kind will not coerce input values to any particular scale, whereas numeric columns with a declared scale will coerce input values to that scale.


Numeric values are physically stored without any extra leading or trailing zeroes.

In addition to ordinary numeric values, the numeric type has several special values:
`Infinity`
`-Infinity`
`NaN`

These are adapted from the IEEE 754 standard, and represent “infinity”, “negative infinity”, and “not-a-number”, respectively. When writing these values as constants in a Cypher command, you must put quotes around them, for example MATCH (v) v.i = -Infinity::numeric. On input, these strings are recognized in a case-insensitive manner. The infinity values can alternatively be spelled inf and -inf.

The infinity values behave as per mathematical expectations. For example, Infinity plus any finite value equals Infinity, as does Infinity plus Infinity; but Infinity minus Infinity yields NaN (not a number), because it has no well-defined interpretation. Note that an infinity can only be stored in an unconstrained numeric column, because it notionally exceeds any finite precision limit.

The NaN (not a number) value is used to represent undefined calculational results. In general, any operation with a NaN input yields another NaN. The only exception is when the operation's other inputs are such that the same output would be obtained if the NaN were to be replaced by any finite or infinite numeric value; then, that output value is used for NaN too. (An example of this principle is that NaN raised to the zero power yields one.)

**Note** In most implementations of the “not-a-number” concept, NaN is not considered equal to any other numeric value (including NaN). In order to allow numeric values to be sorted and used in tree-based indexes, PostgreSQL treats NaN values as equal, and greater than all non-NaN values.

When rounding values, the numeric type rounds ties away from zero, while (on most machines) the real and double precision types round ties to the nearest even number. For example:

```sql
SELECT x,
  round(x::numeric::gtype) AS num_round,
  round(x::double::gtype) AS dbl_round
FROM generate_series(-3.5, 3.5, 1) as x;
  x   | num_round | dbl_round
------+-----------+-----------
 -3.5 |        -4 |        -4
 -2.5 |        -3 |        -2
 -1.5 |        -2 |        -2
 -0.5 |        -1 |        -0
  0.5 |         1 |         0
  1.5 |         2 |         2
  2.5 |         3 |         2
  3.5 |         4 |         4
(8 rows)
```

## String

Strings are variable length character type.

## Boolean

## Temporal Types

PostGraph supports Postgres' style temporal types. Dates are counted according to the Gregorian calendar, even in years before that calendar was introduced. See Postgres' [Section B.6](https://www.postgresql.org/docs/current/datetime-units-history.html) for details.

#### Types
| Name | Storage Size | Description | Low Value | High Value | Resolution |
| :--- | ------------ | ----------- | --------- | ---------- | ---------: |
| Timestamp               | 16 Bytes | Date and Time              | 4713 BC          | 293276 AD       | 1 microsecond |
| Timestamp with Time Zone| 16 Bytes | Date and Time with Timezone| 4713 BC          | 293276 AD       | 1 microsecond |
| Date                    | 12 Bytes | Date                       | 4713 BC          | 5874897 AD      | 1 day |
| Time                    | 16 Bytes | Time                       | 4713 BC          | 293276 AD       | 1 microsecond |
| Time with Time Zone     | 20 Bytes | Time with Timezone         | 4713 BC          | 293276 AD       | 1 microsecond |
| Interval                | 24 Bytes | Time Interval              | -178000000 Years | -78000000 Years | 1 microsecond |

**Note** The types are 8 bytes bigger than their Postgres counterparts because GType has to store metadata to know what type is being stored in itself.


#### Date/Time Input

Date and time input is accepted in almost any reasonable format, including ISO 8601, SQL-compatible, traditional POSTGRES, and others. For some formats, ordering of day, month, and year in date input is ambiguous and there is support for specifying the expected ordering of these fields. Set the [DateStyle](https://www.postgresql.org/docs/current/runtime-config-client.html#GUC-DATESTYLE) parameter to MDY to select month-day-year interpretation, DMY to select day-month-year interpretation, or YMD to select year-month-day interpretation.

PostgreSQL is more flexible in handling date/time input than the SQL standard requires. See Appendix B for the exact parsing rules of date/time input and for the recognized text fields including months, days of the week, and time zones.

Date and time literal inputs need to be enclosed in single quotes, like strings. Cypher requires the following two syntax options for creating temporal types

```
type 'value'
'value'::type
```



#### Dates

The possible input formats for the date type and the date part of timestamp and timestamptz.

#####  Date Input
| Example |	Description |
| ------- | ----------- |
| 1999-01-08 | ISO 8601; January 8 in any mode (recommended format) |
| January 8, 1999 | unambiguous in any datestyle input mode |
| 1/8/1999 | January 8 in MDY mode; August 1 in DMY mode |
| 1/18/1999 | January 18 in MDY mode; rejected in other modes |
| 01/02/03 | January 2, 2003 in MDY mode; February 1, 2003 in DMY mode; February 3, 2001 in YMD mode |
| 1999-Jan-08 |January 8 in any mode |
| Jan-08-1999 |January 8 in any mode |
| 08-Jan-1999 | January 8 in any mode |
| 99-Jan-08 | January 8 in YMD mode, else error |
| 08-Jan-99 | January 8, except error in YMD mode |
| Jan-08-99 | January 8, except error in YMD mode |
| 19990108 | ISO 8601; January 8, 1999 in any mode |
| 990108 | ISO 8601; January 8, 1999 in any mode |
| 1999.008 |year and day of year |
| J2451187 |Julian date |
| January 8, 99 BC | year 99 BC |


#### Times

The time-of-day types are time and time with time zone (timetz).

Valid input for these types consists of a time of day followed by an optional time zone. If a time zone is specified in the input for time without time zone, it is silently ignored. You can also specify a date but it will be ignored, except when you use a time zone name that involves a daylight-savings rule, such as `America/New_York`. In this case specifying the date is required in order to determine whether standard or daylight-savings time applies. The appropriate time zone offset is recorded in the time with time zone value.

##### Time Input
| Example | Description |
| ------- | ----------- |
| 04:05:06.789 | ISO 8601 |
| 04:05:06 | ISO 8601 |
| 04:05 | ISO 8601 |
| 040506 | ISO 8601 |
| 04:05 AM | same as 04:05; AM does not affect value |
| 04:05 PM | same as 16:05; input hour must be <= 12 |
| 04:05:06.789-8 | ISO 8601, with time zone as UTC offset |
| 04:05:06-08:00 | ISO 8601, with time zone as UTC offset |
| 04:05-08:00 | ISO 8601, with time zone as UTC offset |
| 040506-08 | ISO 8601, with time zone as UTC offset |
| 040506+0730 | ISO 8601, with fractional-hour time zone as UTC offset |
| 040506+07:30:00 | UTC offset specified to seconds (not allowed in ISO 8601) |
| 04:05:06 PST | time zone specified by abbreviation | 
| 2003-04-12 04:05:06 America/New_York | time zone specified by full name |

##### Time Zone Input
| Example | Description |
| ------- | ----------- |
| PST | Abbreviation (for Pacific Standard Time) |
| America/New_York | Full time zone name |
| PST8PDT | POSIX-style time zone specification |
| -8:00:00 | UTC offset for PST |
| -8:00 | UTC offset for PST (ISO 8601 extended format) |
| -800 | UTC offset for PST (ISO 8601 basic format) |
| -8 | UTC offset for PST (ISO 8601 basic format) |
| zulu | Military abbreviation for UTC |
| z | Short form of zulu (also in ISO 8601) |

Refer to [Section 8.5.3](https://www.postgresql.org/docs/current/datatype-datetime.html#DATATYPE-TIMEZONES) in the PostGres documentation for more information on how to specify time zones.


### Timestamp

Valid input for the time stamp types consists of the concatenation of a date and a time, followed by an optional time zone, followed by an optional AD or BC. (Alternatively, AD/BC can appear before the time zone, but this is not the preferred ordering.) Thus:

```sql
SELECT * FROM cypher('temporal', $$
    RETURN '1999-01-08 04:05:06'::timestamp
$$) as (t gtype);
```

and:

```sql
SELECT * FROM cypher('temporal', $$
    RETURN '1999-01-08 04:05:06 -8:00'::timestamp
$$) as (t gtype);
```


are valid values, which follow the ISO 8601 standard. In addition, the common format:

```sql
SELECT * FROM cypher('temporal', $$
    RETURN 'January 8 04:05:06 1999 PST'::timestamp
$$) as (t gtype);
```

is supported.

The SQL standard differentiates timestamp without time zone and timestamp with time zone literals by the presence of a “+” or “-” symbol and time zone offset after the time. Hence, according to the standard,

```sql
SELECT * FROM cypher('temporal', $$
    RETURN TIMESTAMP '2004-10-19 10:23:54'
$$) as (t gtype);
```

is a timestamp without time zone, while

```sql
SELECT * FROM cypher('temporal', $$
    RETURN TIMESTAMP '2004-10-19 10:23:54+02'
$$) as (t gtype);
```

is a timestamp with time zone. Postgraph never examines the content of a literal string before determining its type, and therefore will treat both of the above as timestamp without time zone. 

In a literal that has been determined to be timestamp without time zone, PostgreSQL will silently ignore any time zone indication. That is, the resulting value is derived from the date/time fields in the input value, and is not adjusted for time zone.


### Timestamp With Time Zone

To ensure that a literal is treated as timestamp with time zone, give it the correct explicit type:

```sql
SELECT * FROM cypher('temporal', $$
    RETURN '2004-10-19 10:23:54+02'timestamptz
$$) as (t gtype);
```

For timestamp with time zone, the internally stored value is always in UTC (Universal Coordinated Time, traditionally known as Greenwich Mean Time, GMT). An input value that has an explicit time zone specified is converted to UTC using the appropriate offset for that time zone. If no time zone is stated in the input string, then it is assumed to be in the time zone indicated by the system's TimeZone parameter, and is converted to UTC using the offset for the timezone zone.

When a timestamp with time zone value is output, it is always converted from UTC to the current timezone zone, and displayed as local time in that zone. To see the time in another time zone, either change timezone or use the AT TIME ZONE construct (see Postgres' [Section 9.9.4](https://www.postgresql.org/docs/current/functions-datetime.html#FUNCTIONS-DATETIME-ZONECONVERT)).

Conversions between timestamp without time zone and timestamp with time zone normally assume that the timestamp without time zone value should be taken or given as timezone local time. A different time zone can be specified for the conversion using AT TIME ZONE.


### Date

### Time

### Time With TimeZone

### Interval

interval values can be written using the following verbose syntax:
```sql
[@] quantity unit [quantity unit...] [direction]
```

where quantity is a number (possibly signed); unit is microsecond, millisecond, second, minute, hour, day, week, month, year, decade, century, millennium, or abbreviations or plurals of these units; direction can be ago or empty. The at sign (@) is optional noise. The amounts of the different units are implicitly added with appropriate sign accounting. ago negates all the fields. This syntax is also used for interval output, if IntervalStyle is set to postgres_verbose.

Quantities of days, hours, minutes, and seconds can be specified without explicit unit markings. For example, '1 12:59:10' is read the same as '1 day 12 hours 59 min 10 sec'. Also, a combination of years and months can be specified with a dash; for example '200-10' is read the same as '200 years 10 months'. (These shorter forms are in fact the only ones allowed by the SQL standard, and are used for output when IntervalStyle is set to sql_standard.)

Interval values can also be written as ISO 8601 time intervals, using either the “format with designators” of the standard's section 4.4.3.2 or the “alternative format” of section 4.4.3.3. The format with designators looks like this:

```sql
P quantity unit [ quantity unit ...] [ T [ quantity unit ...]]
```

The string must start with a P, and may include a T that introduces the time-of-day units. The available unit abbreviations are given in Table 8.16. Units may be omitted, and may be specified in any order, but units smaller than a day must appear after T. In particular, the meaning of M depends on whether it is before or after T.

##### ISO 8601 Interval Unit Abbreviations
| Abbreviation | Meaning |
| ------------ | ------- |
| Y | Years |
| M | Months (in the date part) |
| W | Weeks |
| D | Days |
| H | Hours |
| M | Minutes (in the time part) |
| S | Seconds |

In the alternative format:

```sql
P [ years-months-days ] [ T hours:minutes:seconds ]
```

the string must begin with P, and a T separates the date and time parts of the interval. The values are given as numbers similar to ISO 8601 dates.

When writing an interval constant with a fields specification, or when assigning a string to an interval column that was defined with a fields specification, the interpretation of unmarked quantities depends on the fields. For example `INTERVAL '1' YEAR` is read as 1 year, whereas `INTERVAL '1'` means 1 second. Also, field values “to the right” of the least significant field allowed by the fields specification are silently discarded.

According to the SQL standard all fields of an interval value must have the same sign, so a leading negative sign applies to all fields; for example the negative sign in the interval literal `'-1 2:03:04'` applies to both the days and hour/minute/second parts. PostGraph allows the fields to have different signs, and traditionally treats each field in the textual representation as independently signed, so that the hour/minute/second part is considered positive in this example. If IntervalStyle is set to sql_standard then a leading sign is considered to apply to all fields (but only if no additional signs appear). Otherwise the traditional PostgreSQL interpretation is used. To avoid ambiguity, it's recommended to attach an explicit sign to each field if any field is negative.

Field values can have fractional parts: for example, `'1.5 weeks'` or `'01:02:03.45'`. However, because interval internally stores only three integer units (months, days, microseconds), fractional units must be spilled to smaller units. Fractional parts of units greater than months are rounded to be an integer number of months, e.g. `'1.5 years'` becomes `'1 year 6 mons'`. Fractional parts of weeks and days are computed to be an integer number of days and microseconds, assuming 30 days per month and 24 hours per day, e.g., `'1.75 months'` becomes `1 mon 22 days 12:00:00`. Only seconds will ever be shown as fractional on output.

Table 8.17 shows some examples of valid interval input.

##### Interval Input
| Example | Description |
| ------- | ----------- |
| 1-2 | SQL standard format: 1 year 2 months |
| 3 4:05:06 | SQL standard format: 3 days 4 hours 5 minutes 6 seconds |
| 1 year 2 months 3 days 4 hours 5 minutes 6 seconds | Traditional Postgres format: 1 year 2 months 3 days 4 hours 5 minutes 6 seconds |
| P1Y2M3DT4H5M6S | ISO 8601 “format with designators”: same meaning as above |
| P0001-02-03T04:05:06 | ISO 8601 “alternative format”: same meaning as above |


Internally interval values are stored as months, days, and microseconds. This is done because the number of days in a month varies, and a day can have 23 or 25 hours if a daylight savings time adjustment is involved. The months and days fields are integers while the microseconds field can store fractional seconds. Because intervals are usually created from constant strings or timestamp subtraction, this storage method works well in most cases, but can cause unexpected results:

```sql
SELECT * FROM cypher('temporal', $$
    RETURN SELECT EXTRACT(hours from '80 minutes'::interval)
$$) as (part gtype);
```

##### 
| part |
| ----------- |
| 1 |

```sql
SELECT * FROM cypher('temporal', $$
    RETURN EXTRACT(days from '80 hours'::interval)
$$) as (part gtype);
```

##### 
|  part |
| ----------- |
|         0 |

Functions justify_days and justify_hours are available for adjusting days and hours that overflow their normal ranges.

#### Interval Output

The output format of the interval type can be set to one of the four styles sql_standard, postgres, postgres_verbose, or iso_8601, using the command SET intervalstyle. The default is the postgres format.

The sql_standard style produces output that conforms to the SQL standard's specification for interval literal strings, if the interval value meets the standard's restrictions (either year-month only or day-time only, with no mixing of positive and negative components). Otherwise the output looks like a standard year-month literal string followed by a day-time literal string, with explicit signs added to disambiguate mixed-sign intervals.

The output of the postgres style matches the output of PostgreSQL releases prior to 8.4 when the DateStyle parameter was set to ISO.

The output of the iso_8601 style matches the “format with designators” described in section 4.4.3.2 of the ISO 8601 standard.

##### Interval Output Style Examples
| Style Specification |	Year-Month Interval | Day-Time Interval | Mixed Interval |
| - | - | - | - |
| sql_standard | 1-2 |3 4:05:06 | -1-2 +3 -4:05:06 |
| postgres | 1 year 2 mons |3 days 04:05:06 | -1 year -2 mons +3 days -04:05:06 |
| postgres_verbose | @ 1 year 2 mons |@ 3 days 4 hours 5 mins 6 secs |@ 1 year 2 mons -3 days 4 hours 5 mins 6 secs ago |
| iso_8601 | P1Y2M | P3DT4H5M6S | P-1Y-2M3D-T-4H-5M-6S |

## List

## Map

