"use strict";(self.webpackChunkpostgraph_web=self.webpackChunkpostgraph_web||[]).push([[2409],{3905:(e,t,a)=>{a.d(t,{Zo:()=>p,kt:()=>h});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function l(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?l(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):l(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},l=Object.keys(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var s=n.createContext({}),u=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},p=function(e){var t=u(e.components);return n.createElement(s.Provider,{value:t},e.children)},d="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},c=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,l=e.originalType,s=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),d=u(a),c=r,h=d["".concat(s,".").concat(c)]||d[c]||m[c]||l;return a?n.createElement(h,i(i({ref:t},p),{},{components:a})):n.createElement(h,i({ref:t},p))}));function h(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=a.length,i=new Array(l);i[0]=c;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o[d]="string"==typeof e?e:r,i[1]=o;for(var u=2;u<l;u++)i[u]=a[u];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}c.displayName="MDXCreateElement"},94:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>m,frontMatter:()=>l,metadata:()=>o,toc:()=>u});var n=a(7462),r=(a(7294),a(3905));const l={layout:"default",title:"Float",nav_order:2,description:"Float Graph Type for PostGraph",toc_max_heading_level:2},i="Introduction",o={unversionedId:"Datatypes/gtype/float",id:"Datatypes/gtype/float",title:"Float",description:"Float Graph Type for PostGraph",source:"@site/docs/02-Datatypes/05-gtype/02-float.md",sourceDirName:"02-Datatypes/05-gtype",slug:"/Datatypes/gtype/float",permalink:"/docs/Datatypes/gtype/float",draft:!1,editUrl:"https://github.com/postgraphdb/postgraphdb.github.io/tree/code/docs/02-Datatypes/05-gtype/02-float.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{layout:"default",title:"Float",nav_order:2,description:"Float Graph Type for PostGraph",toc_max_heading_level:2},sidebar:"tutorialSidebar",previous:{title:"Integer",permalink:"/docs/Datatypes/gtype/integer"},next:{title:"Numeric",permalink:"/docs/Datatypes/gtype/numeric"}},s={},u=[{value:"Abs()",id:"abs",level:2},{value:"Syntax",id:"syntax",level:3},{value:"Returns",id:"returns",level:3},{value:"Arguments",id:"arguments",level:3},{value:"Considerations",id:"considerations",level:3},{value:"Example 1. abs()",id:"example-1-abs",level:3},{value:"Query",id:"query",level:4},{value:"Result",id:"result",level:4},{value:"ceil()",id:"ceil",level:2},{value:"Syntax:",id:"syntax-1",level:3},{value:"Returns:",id:"returns-1",level:3},{value:"Arguments:",id:"arguments-1",level:3},{value:"Considerations:",id:"considerations-1",level:3},{value:"Example 2. ceil()",id:"example-2-ceil",level:3},{value:"Query",id:"query-1",level:4},{value:"Result",id:"result-1",level:4},{value:"floor()",id:"floor",level:2},{value:"Syntax",id:"syntax-2",level:3},{value:"Returns",id:"returns-2",level:3},{value:"Arguments",id:"arguments-2",level:3},{value:"Considerations",id:"considerations-2",level:3},{value:"Example 1. floor()",id:"example-1-floor",level:3},{value:"Query",id:"query-2",level:4},{value:"Result",id:"result-2",level:4},{value:"rand()",id:"rand",level:2},{value:"Syntax",id:"syntax-3",level:3},{value:"Returns",id:"returns-3",level:3},{value:"Example 1. rand()",id:"example-1-rand",level:3},{value:"Query",id:"query-3",level:4},{value:"Result",id:"result-3",level:4},{value:"round()",id:"round",level:2},{value:"Syntax",id:"syntax-4",level:3},{value:"Returns",id:"returns-4",level:3},{value:"Arguments",id:"arguments-3",level:3},{value:"Considerations",id:"considerations-3",level:3},{value:"Example 1. round()",id:"example-1-round",level:3},{value:"Query",id:"query-4",level:4},{value:"Result",id:"result-4",level:4},{value:"sign()",id:"sign",level:2},{value:"Syntax",id:"syntax-5",level:3},{value:"Returns",id:"returns-5",level:3},{value:"Arguments",id:"arguments-4",level:3},{value:"Considerations",id:"considerations-4",level:3},{value:"Example 1. sign()",id:"example-1-sign",level:3},{value:"Query",id:"query-5",level:4},{value:"Result",id:"result-5",level:4}],p={toc:u},d="wrapper";function m(e){let{components:t,...a}=e;return(0,r.kt)(d,(0,n.Z)({},p,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"introduction"},"Introduction"),(0,r.kt)("p",null,"A float in PostGraph is an 8-byte inexact variable-precise number. It offers 15 decimal digits of precision."),(0,r.kt)("p",null,"The data type double precision are inexact, variable-precision numeric types. On all currently supported platforms, these types are implementations of IEEE Standard 754 for Binary Floating-Point Arithmetic, to the extent that the underlying processor, operating system, and compiler support it."),(0,r.kt)("p",null,"Inexact means that some values cannot be converted exactly to the internal format and are stored as approximations, so that storing and retrieving a value might show slight discrepancies. Managing these errors and how they propagate through calculations is the subject of an entire branch of mathematics and computer science and will not be discussed here, except for the following points:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"If you require exact storage and calculations (such as for monetary amounts), use the numeric type instead."),(0,r.kt)("li",{parentName:"ul"},"If you want to do complicated calculations with these types for anything important, especially if you rely on certain behavior in boundary cases (infinity, underflow), you should evaluate the implementation carefully."),(0,r.kt)("li",{parentName:"ul"},"Comparing two floating-point values for equality might not always work as expected.")),(0,r.kt)("p",null,"On all currently supported platforms, the ",(0,r.kt)("inlineCode",{parentName:"p"},"double precision")," type has a range of around 1E-307 to 1E+308 with a precision of at least 15 digits. Values that are too large or too small will cause an error. Rounding might take place if the precision of an input number is too high. Numbers too close to zero that are not representable as distinct from zero will cause an underflow error."),(0,r.kt)("p",null,"By default, floating point values are output in text form in their shortest precise decimal representation; the decimal value produced is closer to the true stored binary value than to any other value representable in the same binary precision. (However, the output value is currently never exactly midway between two representable values, in order to avoid a widespread bug where input routines do not properly respect the round-to-nearest-even rule.) This value will use at most 17 significant decimal digits for float8 values, and at most 9 digits for float4 values."),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"This shortest-precise output format is much faster to generate than the historical rounded format.")),(0,r.kt)("p",null,"For compatibility with output generated by older versions of PostgreSQL, and to allow the output precision to be reduced, the ",(0,r.kt)("inlineCode",{parentName:"p"},"extra_float_digits")," parameter can be used to select rounded decimal output instead. Setting a value of 0 restores the previous default of rounding the value to 6 (for float4) or 15 (for float8) significant decimal digits. Setting a negative value reduces the number of digits further; for example -2 would round output to 4 or 13 digits respectively."),(0,r.kt)("p",null,"Any value of ",(0,r.kt)("inlineCode",{parentName:"p"},"extra_float_digits")," greater than 0 selects the shortest-precise format."),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"Applications that wanted precise values have historically had to set ",(0,r.kt)("inlineCode",{parentName:"p"},"extra_float_digits")," to 3 to obtain them. For maximum compatibility between versions, they should continue to do so.")),(0,r.kt)("p",null,"In addition to ordinary numeric values, the floating-point types have several special values:\n",(0,r.kt)("inlineCode",{parentName:"p"},"Infinity"),"\n",(0,r.kt)("inlineCode",{parentName:"p"},"-Infinity"),"\n",(0,r.kt)("inlineCode",{parentName:"p"},"NaN")),(0,r.kt)("p",null,"These represent the IEEE 754 special values \u201cinfinity\u201d, \u201cnegative infinity\u201d, and \u201cnot-a-number\u201d, respectively. When writing these values as constants in an Cypher command, you do not put quotes around them, for example ",(0,r.kt)("inlineCode",{parentName:"p"},"MATCH (v) SET v.i = -Infinity"),". On input, these strings are recognized in a case-sensitive manner. The infinity values can alternatively be spelled inf and ",(0,r.kt)("inlineCode",{parentName:"p"},"-inf"),"."),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"}," IEEE 754 specifies that NaN should not compare equal to any other floating-point value (including NaN). In order to allow floating-point values to be sorted and used in tree-based indexes, PostgreSQL treats NaN values as equal, and greater than all non-NaN values.")),(0,r.kt)("h1",{id:"functions"},"Functions"),(0,r.kt)("h2",{id:"abs"},"Abs()"),(0,r.kt)("p",null,"abs() returns the absolute value of the given number."),(0,r.kt)("h3",{id:"syntax"},"Syntax"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"abs(expression)")),(0,r.kt)("h3",{id:"returns"},"Returns"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"The type of the value returned will be that of expression.")),(0,r.kt)("h3",{id:"arguments"},"Arguments"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:"left"},"Name"),(0,r.kt)("th",{parentName:"tr",align:"center"},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"expression"),(0,r.kt)("td",{parentName:"tr",align:"center"},"A numeric expression.")))),(0,r.kt)("h3",{id:"considerations"},"Considerations"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"abs(null) returns null."),(0,r.kt)("li",{parentName:"ul"},"If expression is negative, -(expression) (i.e. the negation of expression) is returned.")),(0,r.kt)("h3",{id:"example-1-abs"},"Example 1. abs()"),(0,r.kt)("h4",{id:"query"},"Query"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT * FROM cypher('numeric', $$\n    MATCH (a), (e)\n    WHERE a.name = 'Alice' AND e.name = 'Eskil'\n    RETURN a.age, e.age, abs(a.age - e.age)\n$$) as (a_age gtype, e_type, diff_age);\n")),(0,r.kt)("p",null,"The absolute value of the age difference is returned."),(0,r.kt)("h4",{id:"result"},"Result"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:"left"},"a_age"),(0,r.kt)("th",{parentName:"tr",align:"center"},"e_age"),(0,r.kt)("th",{parentName:"tr",align:"right"},"diff_age"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"38"),(0,r.kt)("td",{parentName:"tr",align:"center"},"41"),(0,r.kt)("td",{parentName:"tr",align:"right"},"3")))),(0,r.kt)("h2",{id:"ceil"},"ceil()"),(0,r.kt)("p",null,"ceil() returns the smallest floating point number that is greater than or equal to the given number and equal to a mathematical integer."),(0,r.kt)("h3",{id:"syntax-1"},"Syntax:"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"ceil(expression)")),(0,r.kt)("h3",{id:"returns-1"},"Returns:"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"A Float.")),(0,r.kt)("h3",{id:"arguments-1"},"Arguments:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:"left"},"Name"),(0,r.kt)("th",{parentName:"tr",align:"center"},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"expression"),(0,r.kt)("td",{parentName:"tr",align:"center"},"A numeric expression.")))),(0,r.kt)("h3",{id:"considerations-1"},"Considerations:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"ceil(null) returns null.")),(0,r.kt)("h3",{id:"example-2-ceil"},"Example 2. ceil()"),(0,r.kt)("h4",{id:"query-1"},"Query"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT * FROM cypher('numeric', $$\nRETURN ceil(0.1)\n$$) as (ceil gtype);\n")),(0,r.kt)("p",null,"The ceil of 0.1 is returned."),(0,r.kt)("h4",{id:"result-1"},"Result"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:"left"},"ceil"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"1")))),(0,r.kt)("h2",{id:"floor"},"floor()"),(0,r.kt)("p",null,"floor() returns the largest floating point number that is less than or equal to the given number and equal to a mathematical integer."),(0,r.kt)("h3",{id:"syntax-2"},"Syntax"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"floor(expression)")),(0,r.kt)("h3",{id:"returns-2"},"Returns"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"A Float.")),(0,r.kt)("h3",{id:"arguments-2"},"Arguments"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:"left"},"Name"),(0,r.kt)("th",{parentName:"tr",align:"center"},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"expression"),(0,r.kt)("td",{parentName:"tr",align:"center"},"A numeric expression.")))),(0,r.kt)("h3",{id:"considerations-2"},"Considerations"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"floor(null) returns null.")),(0,r.kt)("h3",{id:"example-1-floor"},"Example 1. floor()"),(0,r.kt)("h4",{id:"query-2"},"Query"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT * FROM cypher('numeric', $$\nRETURN floor(0.9)\n$$) as (ceil gtype);\n")),(0,r.kt)("p",null,"The floor of 0.9 is returned."),(0,r.kt)("h4",{id:"result-2"},"Result"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:"left"},"floor"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"0")))),(0,r.kt)("h2",{id:"rand"},"rand()"),(0,r.kt)("p",null,"rand() returns a random floating point number in the range from 0 (inclusive) to 1 (exclusive); i.e. [0,1). The numbers returned follow an approximate uniform distribution."),(0,r.kt)("h3",{id:"syntax-3"},"Syntax"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"rand()")),(0,r.kt)("h3",{id:"returns-3"},"Returns"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"A Float.")),(0,r.kt)("h3",{id:"example-1-rand"},"Example 1. rand()"),(0,r.kt)("h4",{id:"query-3"},"Query"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT * FROM cypher('numeric', $$\nRETURN rand()\n$$) as (ceil gtype);\n")),(0,r.kt)("p",null,"A random number is returned."),(0,r.kt)("h4",{id:"result-3"},"Result"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:"left"},"rand"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"0.5460251846326871")))),(0,r.kt)("h2",{id:"round"},"round()"),(0,r.kt)("p",null,"round() returns the value of the given number rounded to the nearest integer, with ties always rounded towards positive infinity."),(0,r.kt)("h3",{id:"syntax-4"},"Syntax"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"round(expression)")),(0,r.kt)("h3",{id:"returns-4"},"Returns"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"A Float.")),(0,r.kt)("h3",{id:"arguments-3"},"Arguments"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:"left"},"Name"),(0,r.kt)("th",{parentName:"tr",align:"center"},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"expression"),(0,r.kt)("td",{parentName:"tr",align:"center"},"A numeric expression.")))),(0,r.kt)("h3",{id:"considerations-3"},"Considerations"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"round(null) returns null.")),(0,r.kt)("h3",{id:"example-1-round"},"Example 1. round()"),(0,r.kt)("h4",{id:"query-4"},"Query"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT * FROM cypher('numeric', $$\nRETURN round(3.141592)\n$$) as (ceil gtype);\n")),(0,r.kt)("p",null,"3.0 is returned."),(0,r.kt)("h4",{id:"result-4"},"Result"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:"left"},"rand"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"3.0")))),(0,r.kt)("h2",{id:"sign"},"sign()"),(0,r.kt)("p",null,"sign() returns the signum of the given number: 0 if the number is 0, -1 for any negative number, and 1 for any positive number."),(0,r.kt)("h3",{id:"syntax-5"},"Syntax"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"sign(expression)")),(0,r.kt)("h3",{id:"returns-5"},"Returns"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"An Integer.")),(0,r.kt)("h3",{id:"arguments-4"},"Arguments"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:"left"},"Name"),(0,r.kt)("th",{parentName:"tr",align:"center"},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"expression"),(0,r.kt)("td",{parentName:"tr",align:"center"},"A numeric expression.")))),(0,r.kt)("h3",{id:"considerations-4"},"Considerations"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"sign(null) returns null.")),(0,r.kt)("h3",{id:"example-1-sign"},"Example 1. sign()"),(0,r.kt)("h4",{id:"query-5"},"Query"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT * FROM cypher('numeric', $$\n     RETURN sign(-17), sign(0.1)\n$$) as (neg_sign gtype, pos_sign gtype);\n")),(0,r.kt)("p",null,"The signs of -17 and 0.1 are returned."),(0,r.kt)("h4",{id:"result-5"},"Result"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:"left"},"neg_sign"),(0,r.kt)("th",{parentName:"tr",align:null},"pos_sign"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"-1"),(0,r.kt)("td",{parentName:"tr",align:null},"1")))))}m.isMDXComponent=!0}}]);