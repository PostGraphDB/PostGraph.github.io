"use strict";(self.webpackChunkpostgraph_web=self.webpackChunkpostgraph_web||[]).push([[5583],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>g});var a=n(7294);function l(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){l(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,l=function(e,t){if(null==e)return{};var n,a,l={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(l[n]=e[n]);return l}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(l[n]=e[n])}return l}var o=a.createContext({}),u=function(e){var t=a.useContext(o),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},p=function(e){var t=u(e.components);return a.createElement(o.Provider,{value:t},e.children)},d="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},k=a.forwardRef((function(e,t){var n=e.components,l=e.mdxType,r=e.originalType,o=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),d=u(n),k=l,g=d["".concat(o,".").concat(k)]||d[k]||h[k]||r;return n?a.createElement(g,s(s({ref:t},p),{},{components:n})):a.createElement(g,s({ref:t},p))}));function g(e,t){var n=arguments,l=t&&t.mdxType;if("string"==typeof e||l){var r=n.length,s=new Array(r);s[0]=k;var i={};for(var o in t)hasOwnProperty.call(t,o)&&(i[o]=t[o]);i.originalType=e,i[d]="string"==typeof e?e:l,s[1]=i;for(var u=2;u<r;u++)s[u]=n[u];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}k.displayName="MDXCreateElement"},6218:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>s,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>u});var a=n(7462),l=(n(7294),n(3905));const r={layout:"default",title:"WHERE",nav_order:4,description:"WHERE adds constraints to the patterns in a MATCH or OPTIONAL MATCH clause"},s="WHERE",i={unversionedId:"Clauses/WHERE",id:"Clauses/WHERE",title:"WHERE",description:"WHERE adds constraints to the patterns in a MATCH or OPTIONAL MATCH clause",source:"@site/docs/03-Clauses/11-WHERE.md",sourceDirName:"03-Clauses",slug:"/Clauses/WHERE",permalink:"/docs/Clauses/WHERE",draft:!1,editUrl:"https://github.com/postgraphdb/postgraphdb.github.io/tree/code/docs/03-Clauses/11-WHERE.md",tags:[],version:"current",sidebarPosition:11,frontMatter:{layout:"default",title:"WHERE",nav_order:4,description:"WHERE adds constraints to the patterns in a MATCH or OPTIONAL MATCH clause"},sidebar:"tutorialSidebar",previous:{title:"OPTIONAL MATCH",permalink:"/docs/Clauses/OPTIONAL-MATCH"},next:{title:"LIMIT",permalink:"/docs/Clauses/LIMIT"}},o={},u=[{value:"Introduction",id:"introduction",level:2},{value:"Data Setup",id:"data-setup",level:3},{value:"Basic Usage",id:"basic-usage",level:2},{value:"Boolean Operations",id:"boolean-operations",level:3},{value:"Filter on Vertex Property",id:"filter-on-vertex-property",level:3},{value:"Filter on Edge Property",id:"filter-on-edge-property",level:3},{value:"Property Existence Checking",id:"property-existence-checking",level:3},{value:"String Matching",id:"string-matching",level:2},{value:"Basic String Matching",id:"basic-string-matching",level:3},{value:"Starts With",id:"starts-with",level:4},{value:"Ends With",id:"ends-with",level:4},{value:"Contains",id:"contains",level:4},{value:"Regular Expressions",id:"regular-expressions",level:3},{value:"Path Patterns With Exists",id:"path-patterns-with-exists",level:2},{value:"Filter on Patterns",id:"filter-on-patterns",level:3},{value:"Filter on Patterns using NOT",id:"filter-on-patterns-using-not",level:3},{value:"Filter on Patterns with Properties",id:"filter-on-patterns-with-properties",level:3},{value:"Lists",id:"lists",level:2},{value:"In Operator",id:"in-operator",level:3},{value:"Missing Propertiues and Values",id:"missing-propertiues-and-values",level:2},{value:"Default to false if Property is Missing",id:"default-to-false-if-property-is-missing",level:3},{value:"Default to true if Property is Missing",id:"default-to-true-if-property-is-missing",level:3},{value:"Filter on NULL",id:"filter-on-null",level:3},{value:"Using Ranges",id:"using-ranges",level:2},{value:"Simple Range",id:"simple-range",level:3},{value:"Composite Range",id:"composite-range",level:3}],p={toc:u},d="wrapper";function h(e){let{components:t,...n}=e;return(0,l.kt)(d,(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("h1",{id:"where"},"WHERE"),(0,l.kt)("h2",{id:"introduction"},"Introduction"),(0,l.kt)("p",null,"WHERE is not a clause in its own right \u2014 rather, it\u2019s part of MATCH, OPTIONAL MATCH, START and WITH.\nIn the case of WITH and START, WHERE simply filters the results.\nFor MATCH and OPTIONAL MATCH on the other hand, WHERE adds constraints to the patterns described. It\nshould not be seen as a filter after the matching is finished."),(0,l.kt)("p",null,"In the case of multiple MATCH / OPTIONAL MATCH clauses, the predicate in WHERE is\nalways a part of the patterns in the directly preceding MATCH / OPTIONAL MATCH. Both\nresults and performance may be impacted if the WHERE is put inside the wrong\nMATCH clause."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"NOTE")," The previous statement is temporary and will be removed in a future release."),(0,l.kt)("h3",{id:"data-setup"},"Data Setup"),(0,l.kt)("p",null,"The following graph is used for the examples below:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT create_graph('where');\n\nSELECT * FROM cypher('where', $$\n CREATE (andres:Swedish {name: 'Andres', age: 36, belt: 'white'}),\n        (peter:Person {name: 'Peter', email: 'peter_n@example.com', age: 35}),\n        (tobias:Person {name: 'Tobias', address: 'Sweden/Malmo', age: 25}),\n        (andres)-[:KNOWS {since: 1999}]->(peter)\n        (andres)-[:KNOWS {since: 2012}]->(tobias)\n$$) as (a gtype);\n")),(0,l.kt)("h2",{id:"basic-usage"},"Basic Usage"),(0,l.kt)("h3",{id:"boolean-operations"},"Boolean Operations"),(0,l.kt)("p",null,"You can use the boolean operators AND, OR, XOR and NOT. See Working with null for more information\non how this works with null."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT * FROM cypher('where', $$\n    MATCH (n)\n    WHERE n.name = 'Peter' XOR (n.age < 30 AND n.name = 'Tobias') OR NOT (n.name = 'Tobias' OR n.name = 'Peter')\n    RETURN n.name, n.age\n$$) as (name text, age int);\n")),(0,l.kt)("table",null,(0,l.kt)("tr",null," ",(0,l.kt)("th",null,"name")," ",(0,l.kt)("th",null,"age")," "),(0,l.kt)("tr",null," ",(0,l.kt)("td",null,'"Andres"')," ",(0,l.kt)("td",null,"36")),(0,l.kt)("tr",null," ",(0,l.kt)("td",null,'"Tobias"')," ",(0,l.kt)("td",null,"25")),(0,l.kt)("tr",null," ",(0,l.kt)("td",null,'"Peter"')," ",(0,l.kt)("td",null,"35"))),(0,l.kt)("h3",{id:"filter-on-vertex-property"},"Filter on Vertex Property"),(0,l.kt)("p",null,"To filter on a vertex property, write your clause after the WHERE keyword."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT * FROM cypher('where', $$\n    MATCH (v)\n    WHERE n.age < 30\n    RETURN v.name, v.age\n$$) as (name text, age int);\n")),(0,l.kt)("p",null,"The name and age values for the 'Tobias' node are returned because he is less than 30 years of age."),(0,l.kt)("table",null,(0,l.kt)("tr",null," ",(0,l.kt)("th",null,"name")," ",(0,l.kt)("th",null,"age")," "),(0,l.kt)("tr",null," ",(0,l.kt)("td",null,'"Tobias"')," ",(0,l.kt)("td",null,"25"))),(0,l.kt)("h3",{id:"filter-on-edge-property"},"Filter on Edge Property"),(0,l.kt)("p",null,"To filter on an edge property, write your clause after the WHERE keyword."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT * FROM cypher('where', $$\n    MATCH (:Person)-[l:KNOWS]->(f)\n    WHERE n.since < 2000\n    RETURN f.name, f.age, f.email\n$$) as (name text, age int, email text);\n")),(0,l.kt)("table",null,(0,l.kt)("tr",null," ",(0,l.kt)("th",null,"name")," ",(0,l.kt)("th",null,"age")," ",(0,l.kt)("th",null,"email")," "),(0,l.kt)("tr",null," ",(0,l.kt)("td",null,'"Peter"')," ",(0,l.kt)("td",null,"35")," ",(0,l.kt)("td",null,'"peter_n@example.com"'))),(0,l.kt)("h3",{id:"property-existence-checking"},"Property Existence Checking"),(0,l.kt)("p",null,"To filter on a vertex property, write your clause after the WHERE keyword."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT * FROM cypher('where', $$\n    MATCH (v)\n    WHERE n.belt IS NOT NULL\n    RETURN v.name, v.belt\n$$) as (name text, age text);\n")),(0,l.kt)("p",null,"The name and belt values for the 'Andy' vertex are returned because he is the only one with a belt property"),(0,l.kt)("table",null,(0,l.kt)("tr",null," ",(0,l.kt)("th",null,"name")," ",(0,l.kt)("th",null,"belt")," "),(0,l.kt)("tr",null," ",(0,l.kt)("td",null,'"Andy"')," ",(0,l.kt)("td",null,'"white"'))),(0,l.kt)("h2",{id:"string-matching"},"String Matching"),(0,l.kt)("h3",{id:"basic-string-matching"},"Basic String Matching"),(0,l.kt)("p",null,"The start and end of strings can be matched using ",(0,l.kt)("strong",{parentName:"p"},"STARTS WITH")," and ",(0,l.kt)("strong",{parentName:"p"},"ENDS WITH"),". To match regardless of location in a string, use ",(0,l.kt)("strong",{parentName:"p"},"CONTAINS"),". The matching is case-sensitive."),(0,l.kt)("h4",{id:"starts-with"},"Starts With"),(0,l.kt)("p",null,"The ",(0,l.kt)("strong",{parentName:"p"},"STARTS WITH")," operator is used to perform case-sensitive matching on the start of strings."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT * FROM cypher('where', $$\n    MATCH (v)\n    WHERE n.name STARTS WTIH 'Pet'\n    RETURN v.name, v.age\n$$) as (name text, age int);\n")),(0,l.kt)("p",null,"The name and age values for the 'Peter' node are returned because his name starts with 'Pet'."),(0,l.kt)("table",null,(0,l.kt)("tr",null," ",(0,l.kt)("th",null,"name")," ",(0,l.kt)("th",null,"age")," "),(0,l.kt)("tr",null," ",(0,l.kt)("td",null,'"Peter"')," ",(0,l.kt)("td",null,"35"))),(0,l.kt)("h4",{id:"ends-with"},"Ends With"),(0,l.kt)("p",null,"The ",(0,l.kt)("strong",{parentName:"p"},"END WITH")," operator is used to perform case-sensitive matching on the end of strings."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT * FROM cypher('where', $$\n    MATCH (v)\n    WHERE n.name ENDS WTIH 'ter'\n    RETURN v.name, v.age\n$$) as (name text, age int);\n")),(0,l.kt)("p",null,"The name and age values for the 'Peter' node are returned because his name ends with 'ter'."),(0,l.kt)("table",null,(0,l.kt)("tr",null," ",(0,l.kt)("th",null,"name")," ",(0,l.kt)("th",null,"age")," "),(0,l.kt)("tr",null," ",(0,l.kt)("td",null,'"Peter"')," ",(0,l.kt)("td",null,"35"))),(0,l.kt)("h4",{id:"contains"},"Contains"),(0,l.kt)("p",null,"The ",(0,l.kt)("strong",{parentName:"p"},"CONTAINS")," operator is used to perform case-sensitive matching on the end of strings."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT * FROM cypher('where', $$\n    MATCH (v)\n    WHERE n.name CONTAINS 'ete'\n    RETURN v.name, v.age\n$$) as (name text, age int);\n")),(0,l.kt)("p",null,"The name and age values for the 'Peter' node are returned because his name contains 'ete'."),(0,l.kt)("table",null,(0,l.kt)("tr",null," ",(0,l.kt)("th",null,"name")," ",(0,l.kt)("th",null,"age")," "),(0,l.kt)("tr",null," ",(0,l.kt)("td",null,'"Peter"')," ",(0,l.kt)("td",null,"35"))),(0,l.kt)("h3",{id:"regular-expressions"},"Regular Expressions"),(0,l.kt)("h2",{id:"path-patterns-with-exists"},"Path Patterns With Exists"),(0,l.kt)("h3",{id:"filter-on-patterns"},"Filter on Patterns"),(0,l.kt)("p",null,"Patterns are not only expressions, they are also predicates. The only limitation to your pattern is that you must be able to express it in a single path. You cannot use commas between multiple paths like you do in ",(0,l.kt)("strong",{parentName:"p"},"MATCH"),". You can achieve the same effect by combining multiple patterns with ",(0,l.kt)("strong",{parentName:"p"},"AND"),". Note that you cannot introduce new variables here. Although it might look very similar to the ",(0,l.kt)("strong",{parentName:"p"},"MATCH")," patterns, the ",(0,l.kt)("strong",{parentName:"p"},"WHERE")," clause is all about eliminating matched subgraphs. ",(0,l.kt)("strong",{parentName:"p"},"MATCH (a)-","[*]","->(b)")," is very different from ",(0,l.kt)("strong",{parentName:"p"},"WHERE exists((a)-","[*]","->(b))"),". The first will produce a subgraph for every path it can find between ",(0,l.kt)("strong",{parentName:"p"},"a")," and ",(0,l.kt)("strong",{parentName:"p"},"b"),", whereas the latter will eliminate any matched subgraphs where ",(0,l.kt)("strong",{parentName:"p"},"a")," and ",(0,l.kt)("strong",{parentName:"p"},"b")," do not have a directed edge chain between them."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT * FROM cypher('where', $$\n    MATCH (tobias {name: 'Tobias'}), (others)\n    WHERE others.name IN ['Andres', 'Peter']\n    AND EXISTS((tobias)<-[]-(others))\n    RETURN others.name, others.age\n$$) as (name text, age int);\n")),(0,l.kt)("p",null,"The name and age for nodes that have an outgoing edge to the ",(0,l.kt)("strong",{parentName:"p"},"'Tobias'")," node are returned."),(0,l.kt)("table",null,(0,l.kt)("tr",null," ",(0,l.kt)("th",null,"name")," ",(0,l.kt)("th",null,"age")," "),(0,l.kt)("tr",null," ",(0,l.kt)("td",null,'"Andres"')," ",(0,l.kt)("td",null,"36"))),(0,l.kt)("h3",{id:"filter-on-patterns-using-not"},"Filter on Patterns using NOT"),(0,l.kt)("p",null,"The NOT operator can be used to exclude a pattern."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT * FROM cypher('where', $$\n    MATCH (persons), (peter {name: 'Peter'})\n    WHERE NOT EXISTS((persons)-[]->(peter))\n    RETURN persons.name, persons.age\n$$) as (name text, age int);\n")),(0,l.kt)("p",null,"Name and age values for nodes that do not have an outgoing edge to the 'Peter' node are returned."),(0,l.kt)("table",null,(0,l.kt)("tr",null," ",(0,l.kt)("th",null,"name")," ",(0,l.kt)("th",null,"age")," "),(0,l.kt)("tr",null," ",(0,l.kt)("td",null,'"Tobias"')," ",(0,l.kt)("td",null,"25")),(0,l.kt)("tr",null," ",(0,l.kt)("td",null,'"Peter"')," ",(0,l.kt)("td",null,"35"))),(0,l.kt)("h3",{id:"filter-on-patterns-with-properties"},"Filter on Patterns with Properties"),(0,l.kt)("p",null,"You can also add properties to your patterns."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT * FROM cypher('where', $$\n    MATCH (n)\n    WHERE EXISTS((n)-[:KNOWS]-({name: 'Tobias'}))\n    RETURN n.name, n.age\n$$) as (name text, age int);\n")),(0,l.kt)("p",null,"Name and age values for nodes that do not have an outgoing edge to the 'Peter' node are returned."),(0,l.kt)("table",null,(0,l.kt)("tr",null," ",(0,l.kt)("th",null,"name")," ",(0,l.kt)("th",null,"age")," "),(0,l.kt)("tr",null," ",(0,l.kt)("td",null,'"Andres"')," ",(0,l.kt)("td",null,"36"))),(0,l.kt)("h2",{id:"lists"},"Lists"),(0,l.kt)("h3",{id:"in-operator"},"In Operator"),(0,l.kt)("p",null,"To check if an element exists in a list, you can use the IN operator."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT * FROM cypher('where', $$\n    MATCH (a)\n    WHERE a.name IN ['Peter', 'Tobias']\n    RETURN a.name, a.age\n$$) as (name text, age int);\n")),(0,l.kt)("table",null,(0,l.kt)("tr",null," ",(0,l.kt)("th",null,"name")," ",(0,l.kt)("th",null,"age")," "),(0,l.kt)("tr",null," ",(0,l.kt)("td",null,'"Tobias"')," ",(0,l.kt)("td",null,"25")),(0,l.kt)("tr",null," ",(0,l.kt)("td",null,'"Peter"')," ",(0,l.kt)("td",null,"35"))),(0,l.kt)("h2",{id:"missing-propertiues-and-values"},"Missing Propertiues and Values"),(0,l.kt)("h3",{id:"default-to-false-if-property-is-missing"},"Default to false if Property is Missing"),(0,l.kt)("p",null,"As missing properties evaluate to null, the comparision in the example will evaluate to false for\nnodes without the belt property."),(0,l.kt)("p",null,"You can also add properties to your patterns."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT * FROM cypher('where', $$\n    MATCH (n)\n    WHERE n.belt = 'white'\n    RETURN n.name, n.age, n.belt\n$$) as (name text, age int, belt text);\n")),(0,l.kt)("p",null,"Only the name, age and belt values of nodes with white belts are returned."),(0,l.kt)("table",null,(0,l.kt)("tr",null," ",(0,l.kt)("th",null,"name")," ",(0,l.kt)("th",null,"age")," ",(0,l.kt)("th",null,"belt")," "),(0,l.kt)("tr",null," ",(0,l.kt)("td",null,'"Andres"')," ",(0,l.kt)("td",null,"36")," ",(0,l.kt)("td",null,"white"))),(0,l.kt)("h3",{id:"default-to-true-if-property-is-missing"},"Default to true if Property is Missing"),(0,l.kt)("p",null,"If you want to compare a property on a graph element, but only if it exists, you can compare the\nproperty against both the value you are looking for and null, like:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT * FROM cypher('where', $$\n    MATCH (n)\n    WHERE n.belt = 'white' OR n.belt IS NULL\n    RETURN n.name, n.age, n.belt\n    ORDER BY n.name\n$$) as (name text, age int, belt text);\n")),(0,l.kt)("p",null,"This returns all values for all nodes, even those without the belt property."),(0,l.kt)("table",null,(0,l.kt)("tr",null," ",(0,l.kt)("th",null,"name")," ",(0,l.kt)("th",null,"age")," ",(0,l.kt)("th",null,"belt")," "),(0,l.kt)("tr",null," ",(0,l.kt)("td",null,'"Andres"')," ",(0,l.kt)("td",null,"36")," ",(0,l.kt)("td",null,"white")),(0,l.kt)("tr",null," ",(0,l.kt)("td",null,'"Peter"')," ",(0,l.kt)("td",null,"35")," ",(0,l.kt)("td",null)),(0,l.kt)("tr",null," ",(0,l.kt)("td",null,'"Tobias"')," ",(0,l.kt)("td",null,"25")," ",(0,l.kt)("td",null))),(0,l.kt)("h3",{id:"filter-on-null"},"Filter on NULL"),(0,l.kt)("p",null,"Sometimes you might want to test if a value or a variable is null. This is done just like SQL does it, using IS NULL. Also like SQL, the negative is IS NOT NULL, although NOT(IS NULL x) also works."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT * FROM cypher('where', $$\n    MATCH (n)\n    WHERE n.name = 'Peter' AND n.belt IS NULL\n    RETURN n.name, n.age, n.belt\n$$) as (name text, age int, belt text);\n")),(0,l.kt)("table",null,(0,l.kt)("tr",null," ",(0,l.kt)("th",null,"name")," ",(0,l.kt)("th",null,"age")," ",(0,l.kt)("th",null,"belt")," "),(0,l.kt)("tr",null," ",(0,l.kt)("td",null,'"Peter"')," ",(0,l.kt)("td",null,"35")," ",(0,l.kt)("td",null))),(0,l.kt)("h2",{id:"using-ranges"},"Using Ranges"),(0,l.kt)("h3",{id:"simple-range"},"Simple Range"),(0,l.kt)("p",null,"To check for an element being inside a specific range, use the inequality operators <, <=, >=, >."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT * FROM cypher('where', $$\n    MATCH (a)\n    WHERE a.name >= 'Peter'\n    RETURN a.name, a.age\n$$) as (name text, age int);\n")),(0,l.kt)("p",null,"The name and age values of nodes having a name property lexicographically greater than or equal to 'Peter' are returned."),(0,l.kt)("table",null,(0,l.kt)("tr",null," ",(0,l.kt)("th",null,"name")," ",(0,l.kt)("th",null,"age")," "),(0,l.kt)("tr",null," ",(0,l.kt)("td",null,'"Tobias"')," ",(0,l.kt)("td",null,"25")," "),(0,l.kt)("tr",null," ",(0,l.kt)("td",null,'"Peter"')," ",(0,l.kt)("td",null,"35")," ")),(0,l.kt)("h3",{id:"composite-range"},"Composite Range"),(0,l.kt)("p",null,"Several inequalities can be used to construct a range."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT * FROM cypher('where', $$\n    MATCH (a)\n    WHERE a.name > 'Andres' AND a.name < 'Tobias'\n    RETURN a.name, a.age\n$$) as (name text, age int);\n")),(0,l.kt)("p",null,"The name and age values of nodes having a name property lexicographically between 'Andres' and 'Tobias' are returned."),(0,l.kt)("table",null,(0,l.kt)("tr",null," ",(0,l.kt)("th",null,"name")," ",(0,l.kt)("th",null,"age")," "),(0,l.kt)("tr",null," ",(0,l.kt)("td",null,'"Peter"')," ",(0,l.kt)("td",null,"35")," ")))}h.isMDXComponent=!0}}]);