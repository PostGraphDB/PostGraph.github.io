"use strict";(self.webpackChunkpostgraph_web=self.webpackChunkpostgraph_web||[]).push([[7872],{3905:(e,t,r)=>{r.d(t,{Zo:()=>d,kt:()=>c});var a=r(7294);function n(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function l(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,a)}return r}function i(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?l(Object(r),!0).forEach((function(t){n(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):l(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function o(e,t){if(null==e)return{};var r,a,n=function(e,t){if(null==e)return{};var r,a,n={},l=Object.keys(e);for(a=0;a<l.length;a++)r=l[a],t.indexOf(r)>=0||(n[r]=e[r]);return n}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)r=l[a],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(n[r]=e[r])}return n}var s=a.createContext({}),u=function(e){var t=a.useContext(s),r=t;return e&&(r="function"==typeof e?e(t):i(i({},t),e)),r},d=function(e){var t=u(e.components);return a.createElement(s.Provider,{value:t},e.children)},p="mdxType",g={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var r=e.components,n=e.mdxType,l=e.originalType,s=e.parentName,d=o(e,["components","mdxType","originalType","parentName"]),p=u(r),m=n,c=p["".concat(s,".").concat(m)]||p[m]||g[m]||l;return r?a.createElement(c,i(i({ref:t},d),{},{components:r})):a.createElement(c,i({ref:t},d))}));function c(e,t){var r=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var l=r.length,i=new Array(l);i[0]=m;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o[p]="string"==typeof e?e:n,i[1]=o;for(var u=2;u<l;u++)i[u]=r[u];return a.createElement.apply(null,i)}return a.createElement.apply(null,r)}m.displayName="MDXCreateElement"},9096:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>g,frontMatter:()=>l,metadata:()=>o,toc:()=>u});var a=r(7462),n=(r(7294),r(3905));const l={layout:"default",title:"ORDER BY",nav_order:12,description:"ORDER BY is a sub-clause following RETURN or WITH, and it specifies that the output should be sorted and how."},i="Order By",o={unversionedId:"Clauses/ORDER_BY",id:"Clauses/ORDER_BY",title:"ORDER BY",description:"ORDER BY is a sub-clause following RETURN or WITH, and it specifies that the output should be sorted and how.",source:"@site/docs/03-Clauses/12-ORDER_BY.md",sourceDirName:"03-Clauses",slug:"/Clauses/ORDER_BY",permalink:"/docs/Clauses/ORDER_BY",draft:!1,editUrl:"https://github.com/postgraphdb/postgraphdb.github.io/tree/code/docs/03-Clauses/12-ORDER_BY.md",tags:[],version:"current",sidebarPosition:12,frontMatter:{layout:"default",title:"ORDER BY",nav_order:12,description:"ORDER BY is a sub-clause following RETURN or WITH, and it specifies that the output should be sorted and how."},sidebar:"tutorialSidebar",previous:{title:"LIMIT",permalink:"/docs/Clauses/LIMIT"},next:{title:"SKIP",permalink:"/docs/Clauses/SKIP"}},s={},u=[{value:"Introduction",id:"introduction",level:2},{value:"Order vertices by property",id:"order-vertices-by-property",level:2},{value:"Query",id:"query",level:3},{value:"Result",id:"result",level:3},{value:"Order vertices by multiple properties",id:"order-vertices-by-multiple-properties",level:2},{value:"Query",id:"query-1",level:3},{value:"Result",id:"result-1",level:3},{value:"Order vertices by ID",id:"order-vertices-by-id",level:2},{value:"Query",id:"query-2",level:3},{value:"Results",id:"results",level:3},{value:"Query",id:"query-3",level:3},{value:"Result",id:"result-2",level:3},{value:"Order vertices in descending order",id:"order-vertices-in-descending-order",level:2},{value:"Query",id:"query-4",level:3},{value:"Result",id:"result-3",level:3},{value:"Ordering null",id:"ordering-null",level:2},{value:"Query",id:"query-5",level:3},{value:"Result",id:"result-4",level:3},{value:"Ordering in a WITH clause",id:"ordering-in-a-with-clause",level:2},{value:"Query",id:"query-6",level:3},{value:"Result names",id:"result-names",level:3}],d={toc:u},p="wrapper";function g(e){let{components:t,...r}=e;return(0,n.kt)(p,(0,a.Z)({},d,r,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("h1",{id:"order-by"},"Order By"),(0,n.kt)("h2",{id:"introduction"},"Introduction"),(0,n.kt)("p",null,"ORDER BY relies on comparisons to sort the output, see Ordering and comparison of values. You can sort on many different values, e.g. vertex/edge properties, the vertex/edge ids, or on most expressions. If you do not specify what to sort on, there is a risk that the results are arbitrarily sorted and therefore it is best practice to be specific when using ORDER BY."),(0,n.kt)("p",null,"In terms of scope of variables, ORDER BY follows special rules, depending on if the projecting RETURN or WITH clause is either aggregating or DISTINCT. If it is an aggregating or DISTINCT projection, only the variables available in the projection are available. If the projection does not alter the output cardinality (which aggregation and DISTINCT do), variables available from before the projecting clause are also available. When the projection clause shadows already existing variables, only the new variables are available."),(0,n.kt)("p",null,"Lastly, it is not allowed to use aggregating expressions in the ORDER BY sub-clause if they are not also listed in the projecting clause. This last rule is to make sure that ORDER BY does not change the results, only the order of them."),(0,n.kt)("h2",{id:"order-vertices-by-property"},"Order vertices by property"),(0,n.kt)("p",null,"ORDER BY is used to sort the output."),(0,n.kt)("h3",{id:"query"},"Query"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT * FROM cypher('order', $$\n    MATCH (n)\n    RETURN n.name, n.age\n    ORDER BY n.name\n$$) as (age gtype, name gtype);\n")),(0,n.kt)("p",null,"The vertices are returned, sorted by their name."),(0,n.kt)("h3",{id:"result"},"Result"),(0,n.kt)("table",null,(0,n.kt)("thead",{parentName:"table"},(0,n.kt)("tr",{parentName:"thead"},(0,n.kt)("th",{parentName:"tr",align:null},"name"),(0,n.kt)("th",{parentName:"tr",align:null},"age"))),(0,n.kt)("tbody",{parentName:"table"},(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},'"A"'),(0,n.kt)("td",{parentName:"tr",align:null},"34")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},'"B"'),(0,n.kt)("td",{parentName:"tr",align:null},"36")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},'"C"'),(0,n.kt)("td",{parentName:"tr",align:null},"32")))),(0,n.kt)("h2",{id:"order-vertices-by-multiple-properties"},"Order vertices by multiple properties"),(0,n.kt)("p",null,"You can order by multiple properties by stating each variable in the ORDER BY clause. Cypher will sort the result by the first variable listed, and for equals values, go to the next property in the ORDER BY clause, and so on."),(0,n.kt)("h3",{id:"query-1"},"Query"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT * FROM cypher('order', $$\n    MATCH (n)\n    RETURN n.name, n.age\n    ORDER BY n.age, n.name\n$$) as (age gtype, name gtype);\n")),(0,n.kt)("p",null,"This returns the vertices, sorted first by their age, and then by their name."),(0,n.kt)("h3",{id:"result-1"},"Result"),(0,n.kt)("table",null,(0,n.kt)("thead",{parentName:"table"},(0,n.kt)("tr",{parentName:"thead"},(0,n.kt)("th",{parentName:"tr",align:null},"name"),(0,n.kt)("th",{parentName:"tr",align:null},"age"))),(0,n.kt)("tbody",{parentName:"table"},(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},'"C"'),(0,n.kt)("td",{parentName:"tr",align:null},"32")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},'"A"'),(0,n.kt)("td",{parentName:"tr",align:null},"34")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},'"B"'),(0,n.kt)("td",{parentName:"tr",align:null},"36")))),(0,n.kt)("h2",{id:"order-vertices-by-id"},"Order vertices by ID"),(0,n.kt)("p",null,"ORDER BY is used to sort the output."),(0,n.kt)("h3",{id:"query-2"},"Query"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT * FROM cypher('order', $$\n    MATCH (n)\n    RETURN n.name, n.age\n    ORDER BY id(n)\n$$) as (age gtype, name gtype);\n")),(0,n.kt)("p",null,"The vertices are returned, sorted by their internal ID."),(0,n.kt)("h3",{id:"results"},"Results"),(0,n.kt)("table",null,(0,n.kt)("thead",{parentName:"table"},(0,n.kt)("tr",{parentName:"thead"},(0,n.kt)("th",{parentName:"tr",align:null},"name"),(0,n.kt)("th",{parentName:"tr",align:null},"age"))),(0,n.kt)("tbody",{parentName:"table"},(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},'"A"'),(0,n.kt)("td",{parentName:"tr",align:null},"34")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},'"B"'),(0,n.kt)("td",{parentName:"tr",align:null},"36")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},'"C"'),(0,n.kt)("td",{parentName:"tr",align:null},"32")))),(0,n.kt)("p",null,"Order vertices by expression"),(0,n.kt)("p",null,"ORDER BY is used to sort the output."),(0,n.kt)("h3",{id:"query-3"},"Query"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT * FROM cypher('order', $$\n    MATCH (n)\n    RETURN n.name, n.age, n.length\n    ORDER BY keys(n)\n$$) as (age gtype, name gtype, length gtype);\n")),(0,n.kt)("p",null,"The vertices are returned, sorted by their properties."),(0,n.kt)("h3",{id:"result-2"},"Result"),(0,n.kt)("table",null,(0,n.kt)("thead",{parentName:"table"},(0,n.kt)("tr",{parentName:"thead"},(0,n.kt)("th",{parentName:"tr",align:null},"name"),(0,n.kt)("th",{parentName:"tr",align:null},"age"),(0,n.kt)("th",{parentName:"tr",align:null},"length"))),(0,n.kt)("tbody",{parentName:"table"},(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},'"B"'),(0,n.kt)("td",{parentName:"tr",align:null},"36"),(0,n.kt)("td",{parentName:"tr",align:null},"null")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},'"A"'),(0,n.kt)("td",{parentName:"tr",align:null},"34"),(0,n.kt)("td",{parentName:"tr",align:null},"170")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},'"C"'),(0,n.kt)("td",{parentName:"tr",align:null},"32"),(0,n.kt)("td",{parentName:"tr",align:null},"185")))),(0,n.kt)("h2",{id:"order-vertices-in-descending-order"},"Order vertices in descending order"),(0,n.kt)("p",null,"By adding DESC","[ENDING]"," after the variable to sort on, the sort will be done in reverse order."),(0,n.kt)("h3",{id:"query-4"},"Query"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT * FROM cypher('order', $$\n    MATCH (n)\n    RETURN n.name, n.age\n    ORDER BY n.name DESC\n$$) as (age gtype, name gtype);\n")),(0,n.kt)("p",null,"The example returns the vertices, sorted by their name in reverse order."),(0,n.kt)("h3",{id:"result-3"},"Result"),(0,n.kt)("table",null,(0,n.kt)("thead",{parentName:"table"},(0,n.kt)("tr",{parentName:"thead"},(0,n.kt)("th",{parentName:"tr",align:null},"name"),(0,n.kt)("th",{parentName:"tr",align:null},"age"))),(0,n.kt)("tbody",{parentName:"table"},(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},'"C"'),(0,n.kt)("td",{parentName:"tr",align:null},"32")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},'"B"'),(0,n.kt)("td",{parentName:"tr",align:null},"36")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},'"A"'),(0,n.kt)("td",{parentName:"tr",align:null},"34")))),(0,n.kt)("h2",{id:"ordering-null"},"Ordering null"),(0,n.kt)("p",null,"When sorting the result set, null will always come at the end of the result set for ascending sorting, and first when doing descending sort."),(0,n.kt)("h3",{id:"query-5"},"Query"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT * FROM cypher('order', $$\n    MATCH (n)\n    RETURN n.length, n.name, n.age\n    ORDER BY n.length\n$$) as (length gtype, name gtype, age name);\n")),(0,n.kt)("p",null,"The vertices are returned sorted by the length property, with a vertex without that property last."),(0,n.kt)("h3",{id:"result-4"},"Result"),(0,n.kt)("table",null,(0,n.kt)("thead",{parentName:"table"},(0,n.kt)("tr",{parentName:"thead"},(0,n.kt)("th",{parentName:"tr",align:null},"length"),(0,n.kt)("th",{parentName:"tr",align:null},"name"),(0,n.kt)("th",{parentName:"tr",align:null},"age"))),(0,n.kt)("tbody",{parentName:"table"},(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"170"),(0,n.kt)("td",{parentName:"tr",align:null},'"A"'),(0,n.kt)("td",{parentName:"tr",align:null},"34")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"185"),(0,n.kt)("td",{parentName:"tr",align:null},'"C"'),(0,n.kt)("td",{parentName:"tr",align:null},"32")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"null"),(0,n.kt)("td",{parentName:"tr",align:null},'"B"'),(0,n.kt)("td",{parentName:"tr",align:null},"36")))),(0,n.kt)("h2",{id:"ordering-in-a-with-clause"},"Ordering in a WITH clause"),(0,n.kt)("p",null,"When ORDER BY is present on a WITH clause , the immediately following clause will receive records in the specified order. The order is not guaranteed to be retained after the following clause, unless that also has an ORDER BY subclause. The ordering guarantee can be useful to exploit by operations which depend on the order in which they consume values. For example, this can be used to control the order of items in the list produced by the collect() aggregating function. The MERGE and SET clauses also have ordering dependencies which can be controlled this way."),(0,n.kt)("h3",{id:"query-6"},"Query"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT * FROM cypher('order', $$\n    MATCH (n)\n    WITH n ORDER BY n.age\n    RETURN collect(n.name)\n$$) as (names gtype);\n")),(0,n.kt)("p",null,"The list of names built from the collect aggregating function contains the names in order of the age property.\nTable 7"),(0,n.kt)("h3",{id:"result-names"},"Result names"),(0,n.kt)("table",null,(0,n.kt)("thead",{parentName:"table"},(0,n.kt)("tr",{parentName:"thead"},(0,n.kt)("th",{parentName:"tr",align:null},"names"))),(0,n.kt)("tbody",{parentName:"table"},(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},'["C","A","B"]')))))}g.isMDXComponent=!0}}]);